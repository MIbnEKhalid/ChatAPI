<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inspect Chat Tree | MBK_AI</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg: #050505;
            --panel: #0a0a0a;
            --border: #333;
            --primary: #00ff41;
            --secondary: #bc13fe;
            --text: #e0e0e0;
            --dim: #666;
            --danger: #ff003c;
            --warning: #ffcc00;
            --success: #00ff88;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'JetBrains Mono', monospace;
        }

        body {
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* HEADER */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .meta {
            font-size: 0.9rem;
            color: var(--dim);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .meta span {
            color: #fff;
            font-weight: 400;
        }

        .deleted-badge {
            background: var(--danger);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        /* CONTROL PANEL */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: var(--panel);
            border-radius: 6px;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
            border-right: 1px solid var(--border);
        }

        .control-group:last-child {
            border-right: none;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
        }

/* TREE CONTAINER (Static Window) */
        .chart-wrapper {
            flex: 1;
            overflow: hidden;
            border: 1px solid var(--border);
            border-radius: 6px;
            position: relative;
            
            /* MOVED BACKGROUND HERE for Infinite Effect */
            background-color: #080808;
            background-image: 
                radial-gradient(#222 1px, transparent 1px),
                linear-gradient(90deg, transparent 99px, #111 99px, #111 100px, transparent 100px),
                linear-gradient(transparent 99px, #111 99px, #111 100px, transparent 100px);
            background-size: 20px 20px, 100px 100px, 100px 100px;
        }

        /* MOVING LAYER (Nodes Only) */
        #tree-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Removed background from here */
            transform-origin: 0 0;
            will-change: transform;
        }

        /* NODE STYLES */
        .tree-node {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--border);
            border-left: 4px solid var(--dim);
            width: 220px;
            min-height: 80px;
            padding: 12px;
            border-radius: 6px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            cursor: pointer;
            z-index: 10;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .tree-node:hover {
            z-index: 1000;
            width: 400px;
            min-height: 200px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            background: #111;
            border-color: var(--primary);
        }

        .tree-node.user {
            border-left-color: var(--secondary);
            background: linear-gradient(90deg, rgba(188, 19, 254, 0.05) 0%, rgba(188, 19, 254, 0) 100%);
        }

        .tree-node.model {
            border-left-color: var(--primary);
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.05) 0%, rgba(0, 255, 65, 0) 100%);
        }

        .tree-node.system {
            border-left-color: var(--warning);
            background: linear-gradient(90deg, rgba(255, 204, 0, 0.05) 0%, rgba(255, 204, 0, 0) 100%);
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .node-role {
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: bold;
            color: var(--dim);
            letter-spacing: 1px;
        }

        .node-id {
            font-size: 0.7rem;
            color: var(--dim);
            font-family: monospace;
            background: rgba(255, 255, 255, 0.05);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .node-text {
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }

        .tree-node:hover .node-text {
            -webkit-line-clamp: unset;
            overflow-y: auto;
            max-height: 150px;
            color: #fff;
        }

        .node-timestamp {
            font-size: 0.7rem;
            color: var(--dim);
            margin-top: 8px;
            text-align: right;
        }

        /* CONNECTORS */
        .connector {
            position: absolute;
            background: var(--border);
            height: 2px;
            z-index: 1;
            transform-origin: 0 50%;
            pointer-events: none;
        }

        .connector:hover {
            background: var(--primary);
            height: 3px;
        }

        /* BUTTONS */
        .btn {
            background: #222;
            color: #fff;
            border: 1px solid var(--border);
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.8rem;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            background: #333;
            border-color: var(--primary);
            color: var(--primary);
        }

        .btn-primary {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: #00cc33;
            border-color: #00cc33;
            color: #000;
        }

        .btn-danger {
            background: var(--danger);
            color: #fff;
            border-color: var(--danger);
        }

        .btn-danger:hover {
            background: #cc0029;
            border-color: #cc0029;
        }

        /* LEGEND */
        .legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            font-size: 0.8rem;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .legend h4 {
            margin-bottom: 10px;
            color: var(--primary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 10px;
            border-radius: 2px;
        }

        .legend-user {
            background: var(--secondary);
        }

        .legend-model {
            background: var(--primary);
        }

        .legend-system {
            background: var(--warning);
        }

        /* LOADING */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--primary);
        }

        .spinner {
            border: 3px solid rgba(0, 255, 65, 0.3);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* RESPONSIVE */
        @media (max-width: 1200px) {
            .chart-wrapper {
                padding: 30px;
            }

            .tree-node {
                width: 200px;
            }

            .tree-node:hover {
                width: 350px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .meta {
                flex-direction: column;
                gap: 5px;
            }

            .controls {
                flex-wrap: wrap;
            }

            .chart-wrapper {
                padding: 20px;
            }
        }
    </style>
</head>

<body>

    <div class="header">
        <div>
            <h2><i class="fas fa-network-wired"></i> CHAT_INSPECTOR {{#if chat.is_deleted}}<span
                    class="deleted-badge">DELETED</span>{{/if}}</h2>
            <div class="meta">
                <div><i class="fas fa-user"></i> User: <span>{{chat.username}}</span></div>
                <div><i class="fas fa-calendar"></i> Date: <span>{{chat.created_at}}</span></div>
                <div><i class="fas fa-fingerprint"></i> ID: <span style="font-family:monospace">{{chat.id}}</span></div>
                <div><i class="fas fa-sitemap"></i> Nodes: <span id="node-count">0</span></div>
            </div>
        </div>
        <div>
            <button class="btn" onclick="exportData()"><i class="fas fa-download"></i> Export JSON</button>
            <button class="btn" onclick="toggleLegend()"><i class="fas fa-info-circle"></i> Legend</button>
            <button class="btn btn-primary" onclick="zoomToFit()"><i class="fas fa-expand"></i> Fit View</button>
            <a href="/admin/chats" class="btn"><i class="fas fa-times"></i> Close</a>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="zoom">Zoom:</label>
            <div class="slider-container">
                <i class="fas fa-search-minus"></i>
                <input type="range" id="zoom" min="0.5" max="2" step="0.1" value="1" oninput="updateZoom(this.value)">
                <i class="fas fa-search-plus"></i>
                <span id="zoom-value">100%</span>
            </div>
        </div>

        <div class="control-group">
            <label for="spacing">Spacing:</label>
            <div class="slider-container">
                <i class="fas fa-compress"></i>
                <input type="range" id="spacing" min="50" max="300" step="10" value="120"
                    oninput="updateSpacing(this.value)">
                <i class="fas fa-expand"></i>
                <span id="spacing-value">120px</span>
            </div>
        </div>

        <div class="control-group">
            <button class="btn" onclick="toggleConnectors()"><i class="fas fa-link"></i> Toggle Links</button>
            <button class="btn" onclick="resetView()"><i class="fas fa-redo"></i> Reset</button>
        </div>

        <div class="control-group">
            <label for="node-filter">Filter:</label>
            <select id="node-filter" onchange="filterNodes(this.value)">
                <option value="all">All Nodes</option>
                <option value="user">User Only</option>
                <option value="model">Model Only</option>
                <option value="system">System Only</option>
            </select>
        </div>
    </div>

    <div id="chart-area" class="chart-wrapper">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading chat tree...</p>
        </div>
        <div id="tree-layer"></div>
    </div>

    <div class="legend" id="legend" style="display: none;">
        <h4><i class="fas fa-key"></i> Legend</h4>
        <div class="legend-item">
            <div class="legend-color legend-user"></div>
            <span>User Messages</span>
        </div>
        <div class="legend-item">
            <div class="legend-color legend-model"></div>
            <span>Model Responses</span>
        </div>
        <div class="legend-item">
            <div class="legend-color legend-system"></div>
            <span>System Messages</span>
        </div>
        <hr style="border-color: var(--border); margin: 10px 0;">
        <div style="font-size: 0.7rem; color: var(--dim);">
            <p><i class="fas fa-mouse-pointer"></i> Click nodes to expand</p>
            <p><i class="fas fa-arrows-alt"></i> Drag to pan view</p>
            <p><i class="fas fa-search"></i> Scroll to zoom</p>
        </div>
    </div>

    <script>
        // Sample data structure for testing
        const historyData = {{{ historyJson }}} || {
            nodes: {
                "root": {
                    id: "root",
                    role: "user",
                    text: "Hello, how are you today?",
                    timestamp: "2024-01-15 10:30:00",
                    children: ["node1"],
                    parentId: null
                },
                "node1": {
                    id: "node1",
                    role: "model",
                    text: "I'm doing great! How can I assist you?",
                    timestamp: "2024-01-15 10:30:05",
                    children: ["node2", "node3"],
                    parentId: "root"
                },
                "node2": {
                    id: "node2",
                    role: "user",
                    text: "Tell me about AI",
                    timestamp: "2024-01-15 10:30:10",
                    children: ["node4"],
                    parentId: "node1"
                },
                "node3": {
                    id: "node3",
                    role: "user",
                    text: "What's the weather?",
                    timestamp: "2024-01-15 10:30:12",
                    children: ["node5"],
                    parentId: "node1"
                },
                "node4": {
                    id: "node4",
                    role: "model",
                    text: "AI is the simulation of human intelligence...",
                    timestamp: "2024-01-15 10:30:15",
                    children: [],
                    parentId: "node2"
                },
                "node5": {
                    id: "node5",
                    role: "model",
                    text: "I don't have access to real-time weather data...",
                    timestamp: "2024-01-15 10:30:18",
                    children: [],
                    parentId: "node3"
                }
            },
            rootId: "root"
        };

        // Global variables
        const container = document.getElementById('chart-area');
        const treeLayer = document.getElementById('tree-layer');
        const loading = document.getElementById('loading');
        let zoomLevel = 1;
        let nodeSpacing = 120;
        let connectorsVisible = true;
        let panning = false;
        let startX, startY, translateX = 0, translateY = 0;

        // Layout constants
        const NODE_W = 220;
        const NODE_H = 100;

        // Initialize
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(() => {
                loading.style.display = 'none';
                renderTree();
                setupPanning();
                setupZoom();
            }, 500);
        });

        function renderTree() {
            treeLayer.innerHTML = '';

            if (!historyData.nodes || !historyData.rootId) {
                if (Array.isArray(historyData)) {
                    renderLinearHistory(historyData);
                    return;
                }
                treeLayer.innerHTML = '<div style="color:red; padding:20px;">Invalid Data Structure</div>';
                return;
            }

            const { nodes, rootId } = historyData;

            // Calculate positions using a breadth-first layout
            const positions = calculatePositions(nodes, rootId);

            // Update node count
            document.getElementById('node-count').textContent = Object.keys(nodes).length;

            // Render connectors first (so they appear behind nodes)
            if (connectorsVisible) {
                renderConnectors(nodes, positions);
            }

            // Render nodes
            Object.keys(positions).forEach(id => {
                renderNode(positions[id].x, positions[id].y, nodes[id]);
            });

            // Apply current transform
            updateTransform();
        }

        function calculatePositions(nodes, rootId) {
            const positions = {};
            const depthMap = {};
            let maxDepth = 0;

            // First pass: calculate depth and collect nodes by depth
            function calculateDepth(nodeId, depth) {
                depthMap[nodeId] = depth;
                maxDepth = Math.max(maxDepth, depth);

                const node = nodes[nodeId];
                if (node.children) {
                    node.children.forEach(childId => {
                        calculateDepth(childId, depth + 1);
                    });
                }
            }

            calculateDepth(rootId, 0);

            // Second pass: calculate positions
            const depthCounts = {};

            function positionNode(nodeId, depth, order) {
                const x = 50 + (depth * (NODE_W + nodeSpacing));
                const y = 50 + (order * (NODE_H + nodeSpacing));

                positions[nodeId] = { x, y, depth, order };

                const node = nodes[nodeId];
                if (node.children) {
                    node.children.forEach((childId, idx) => {
                        if (!depthCounts[depth + 1]) depthCounts[depth + 1] = 0;
                        positionNode(childId, depth + 1, depthCounts[depth + 1]++);
                    });
                }
            }

            positionNode(rootId, 0, 0);

            return positions;
        }

        function renderLinearHistory(messages) {
            let y = 50;
            messages.forEach((msg, i) => {
                createNode(50, y, msg.role, msg.parts ? msg.parts[0].text : msg.text, i);
                if (i > 0) {
                    drawConnector(50 + 100, y - nodeSpacing + 80, 50 + 100, y);
                }
                y += nodeSpacing;
            });
        }

        function renderNode(x, y, node) {
            const div = document.createElement('div');
            div.className = `tree-node ${node.role}`;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.dataset.nodeId = node.id;

            const timestamp = node.timestamp || '';
            const displayText = node.text || node.content || '';

            div.innerHTML = `
                <div class="node-header">
                    <div class="node-role">${escapeHtml(node.role)}</div>
                    <div class="node-id">${node.id.substring(0, 8)}...</div>
                </div>
                <div class="node-text">${escapeHtml(displayText.substring(0, 200))}</div>
                ${timestamp ? `<div class="node-timestamp">${timestamp}</div>` : ''}
            `;

            div.addEventListener('click', (e) => {
                e.stopPropagation();
                highlightBranch(node.id);
            });

            treeLayer.appendChild(div);
        }

        function renderConnectors(nodes, positions) {
            Object.keys(positions).forEach(id => {
                const node = nodes[id];
                if (node.parentId && positions[node.parentId]) {
                    const startPos = positions[node.parentId];
                    const endPos = positions[id];

                    drawConnector(
                        startPos.x + NODE_W,
                        startPos.y + 40,
                        endPos.x,
                        endPos.y + 40
                    );
                }
            });
        }

        function drawConnector(x1, y1, x2, y2) {
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            const line = document.createElement('div');
            line.className = 'connector';
            line.style.width = length + 'px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            treeLayer.appendChild(line);
        }

        function createNode(x, y, role, text, id) {
            const div = document.createElement('div');
            div.className = `tree-node ${role}`;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.innerHTML = `
                <div class="node-role">${role}</div>
                <div class="node-text">${escapeHtml(text)}</div>
            `;
            treeLayer.appendChild(div);
        }

        function highlightBranch(nodeId) {
            // Remove previous highlights
            document.querySelectorAll('.tree-node').forEach(node => {
                node.style.boxShadow = '';
                node.style.zIndex = '10';
            });

            // Highlight path to root
            let currentNodeId = nodeId;
            while (currentNodeId && historyData.nodes[currentNodeId]) {
                const node = document.querySelector(`[data-node-id="${currentNodeId}"]`);
                if (node) {
                    node.style.boxShadow = '0 0 20px rgba(0, 255, 65, 0.7)';
                    node.style.zIndex = '100';
                }
                currentNodeId = historyData.nodes[currentNodeId]?.parentId;
            }
        }
function updateTransform() {
            // Move the nodes
            treeLayer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomLevel})`;
            
            // Move the background pattern on the container so it looks infinite
            container.style.backgroundPosition = `${translateX}px ${translateY}px`;
        }

        function setupPanning() {
            // 1. Disable the Right-Click Menu on the chart area
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            // 2. Start Dragging (Left or Right click)
            container.addEventListener('mousedown', (e) => {
                // Allow drag if clicking container or the empty layer (not buttons/nodes)
                if (e.target === container || e.target === treeLayer) {
                    panning = true;
                    // Calculate offset relative to current translation
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    container.style.cursor = 'grabbing';
                }
            });

            // 3. Move (Attached to WINDOW so you don't lose focus)
            window.addEventListener('mousemove', (e) => {
                if (!panning) return;
                e.preventDefault(); // Stop text selection
                
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                
                updateTransform();
            });

            // 4. Stop Dragging (Attached to WINDOW)
            window.addEventListener('mouseup', () => {
                if (panning) {
                    panning = false;
                    container.style.cursor = 'default';
                }
            });
        }
        function setupPanning() {
            container.addEventListener('mousedown', (e) => {
                if (e.target === container) {
                    panning = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    container.style.cursor = 'grabbing';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!panning) return;
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                updateTransform();
            });

            document.addEventListener('mouseup', () => {
                panning = false;
                container.style.cursor = 'default';
            });
        }

function setupZoom() {
            // Track mouse position relative to container
            let mouseX = 0, mouseY = 0;
            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const oldZoom = zoomLevel;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                let newZoom = Math.max(0.5, Math.min(2, oldZoom * zoomFactor));
                
                // Calculate position relative to the content before zooming
                const contentX = (mouseX - translateX) / oldZoom;
                const contentY = (mouseY - translateY) / oldZoom;
                
                // Apply new zoom
                zoomLevel = newZoom;
                
                // Adjust translate to keep the content under the mouse stationary
                translateX = mouseX - (contentX * zoomLevel);
                translateY = mouseY - (contentY * zoomLevel);

                document.getElementById('zoom').value = zoomLevel;
                document.getElementById('zoom-value').textContent = `${Math.round(zoomLevel * 100)}%`;
                updateTransform();
            });
        }

        function updateZoom(value) {
            zoomLevel = parseFloat(value);
            document.getElementById('zoom-value').textContent = `${Math.round(zoomLevel * 100)}%`;
            updateTransform();
        }

        function updateSpacing(value) {
            nodeSpacing = parseInt(value);
            document.getElementById('spacing-value').textContent = `${value}px`;
            renderTree();
        }

        function toggleConnectors() {
            connectorsVisible = !connectorsVisible;
            renderTree();
        }

        function filterNodes(filter) {
            document.querySelectorAll('.tree-node').forEach(node => {
                if (filter === 'all' || node.classList.contains(filter)) {
                    node.style.display = 'block';
                } else {
                    node.style.display = 'none';
                }
            });
        }

        function toggleLegend() {
            const legend = document.getElementById('legend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        }

        function zoomToFit() {
            const nodes = container.querySelectorAll('.tree-node');
            if (nodes.length === 0) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            // FIX: Loop only calculates positions now. 
            // Event listeners have been removed.
            nodes.forEach(node => {
                const x = parseFloat(node.style.left) || 0;
                const y = parseFloat(node.style.top) || 0;
                const width = node.clientWidth || NODE_W;
                const height = node.clientHeight || NODE_H;

                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x + width);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y + height);
            });

            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;

            // Add some padding
            const padding = 100;
            const scaleX = (containerWidth - padding) / contentWidth;
            const scaleY = (containerHeight - padding) / contentHeight;
            const scale = Math.min(scaleX, scaleY, 1); // Cap at 100%

            zoomLevel = Math.max(0.5, scale); // Don't zoom out too far
            document.getElementById('zoom').value = zoomLevel;
            document.getElementById('zoom-value').textContent = `${Math.round(zoomLevel * 100)}%`;

            // Center the content
            translateX = (containerWidth - contentWidth * zoomLevel) / 2 - minX * zoomLevel;
            translateY = (containerHeight - contentHeight * zoomLevel) / 2 - minY * zoomLevel;

            updateTransform();
        }
        function resetView() {
            zoomLevel = 1;
            translateX = 0;
            translateY = 0;
            nodeSpacing = 120;

            document.getElementById('zoom').value = 1;
            document.getElementById('zoom-value').textContent = '100%';
            document.getElementById('spacing').value = 120;
            document.getElementById('spacing-value').textContent = '120px';
            document.getElementById('node-filter').value = 'all';

            updateTransform();
            renderTree();
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function exportData() {
            const blob = new Blob([JSON.stringify(historyData, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat_${historyData.rootId || 'log'}_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>

</html>